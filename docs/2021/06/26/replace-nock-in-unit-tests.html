<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gilda+Display&family=Inter&family=Roboto+Mono:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css">
    <link rel="stylesheet" href="/assets/css/index.css">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <link rel="icon" href="/assets/img/favicon.ico">
    <link type="application/atom+xml" rel="alternate" href="https://kyungeun.kim/feed.xml" title="Kyungeun Kim" />
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Mocking HTTP requests when writing tests (Node.js) | Kyungeun Kim</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Mocking HTTP requests when writing tests (Node.js)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Some alternatives to Nock when mocking HTTP requests in your tests." />
<meta property="og:description" content="Some alternatives to Nock when mocking HTTP requests in your tests." />
<link rel="canonical" href="https://kyungeun.kim/2021/06/26/replace-nock-in-unit-tests.html" />
<meta property="og:url" content="https://kyungeun.kim/2021/06/26/replace-nock-in-unit-tests.html" />
<meta property="og:site_name" content="Kyungeun Kim" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-26T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Mocking HTTP requests when writing tests (Node.js)" />
<meta name="twitter:site" content="@kyungeunni" />
<script type="application/ld+json">
{"description":"Some alternatives to Nock when mocking HTTP requests in your tests.","headline":"Mocking HTTP requests when writing tests (Node.js)","dateModified":"2021-06-26T00:00:00+00:00","datePublished":"2021-06-26T00:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kyungeun.kim/2021/06/26/replace-nock-in-unit-tests.html"},"url":"https://kyungeun.kim/2021/06/26/replace-nock-in-unit-tests.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <div class="container">
      <nav class="nav">
    <div class="nav__menu">
        
            <a href="/" class="nav__item">
                Home
            </a>
        
            <a href="/posts" class="nav__item">
                Posts
            </a>
        
            <a href="/readings" class="nav__item">
                Readings
            </a>
        
    </div>
</nav>

      <div class="main">
        <div class="main__contents">
          <h1 class="post__title">Mocking HTTP requests when writing tests (Node.js)</h1>

<p class="post__meta">
  
    26 Jun 2021
      - <a href="/" class="post__meta-author">Kyungeun Kim</a>
</p>

<div class="post__content">
<p>Quite often we need to mock remote HTTP requests when testing, either for integration tests or unit tests that your logic needs to react differently depending on the variation of the response of the request. There are several options to achieve that, but I will write down my favorite ones.</p>

<h2 id="using-nock">Using Nock</h2>
<p><a href="https://github.com/nock/nock">Nock</a> has been the go-to library when it comes to mocking HTTP requests for tests. It usually looks like this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">nock usage</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">scope</span><span class="p">;</span>

    <span class="nx">beforeEach</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">scope</span> <span class="o">=</span> <span class="nx">nock</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://www.example.com</span><span class="dl">'</span><span class="p">)</span>
            <span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/hello</span><span class="dl">'</span><span class="p">)</span>
            <span class="p">.</span><span class="nx">reply</span><span class="p">(</span><span class="dl">'</span><span class="s1">boo!</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">afterEach</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">scope</span><span class="p">.</span><span class="nx">cleanAll</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>

<p>It is a great tool, quite easy to use and you can see that HTTP requests are invoked for this portion of tests at glance. But sometimes it can be a bit cumbersome to use it. For example, it fails to mock some endpoints depending on how you append the path to base url, whether URL has <code class="language-plaintext highlighter-rouge">/</code> at the end or/and <code class="language-plaintext highlighter-rouge">path</code> starts with <code class="language-plaintext highlighter-rouge">/</code> etc. Or you forgot to <code class="language-plaintext highlighter-rouge">scope.cleanAll</code> or you accidentally use <code class="language-plaintext highlighter-rouge">.persist()</code>, all the following tests can be affected by the interceptors. But the biggest reason I’ve been looking for other solutions is: I just prefer to have fewer dependencies, I just don’t enjoy updating all the code when the newer version of that library requires some updates on my test.</p>

<h2 id="setting-up-your-own-dev-http-server">Setting up your own dev HTTP server</h2>
<p>If it’s simple enough to do so, you can set up your HTTP server that serves the endpoints you need to mock. For instance, I need to test my new authorisation middleware, which will forward the authorization header to auth server to authorise them. my code would look like this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">authMiddleware</span><span class="p">(</span><span class="nx">ctx</span><span class="p">:</span> <span class="nx">Koa</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">next</span><span class="p">:</span> <span class="nx">Koa</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">authorization</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">authorization</span>
    <span class="p">};</span>
    <span class="kd">const</span> <span class="nx">actor</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://internal-auth/authorize,</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">get</span><span class="dl">'</span><span class="p">,</span>
        <span class="nx">headers</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">actor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nx">AuthorizationError</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">url</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">await</span> <span class="nx">next</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>
<p>What we need to do in our dev mock server is:</p>
<ol>
  <li>We should be able to set the url to point to dev server</li>
  <li>Ability to control the response for each test (e.g. authorise the user or not, what data it returns)</li>
</ol>

<p>As most of the time we define config values per environment, we can define one for the test environment and we can make it points to the local one:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AUTH_URL=http://localhost:3003/authorize
</code></pre></div></div>
<p>and use <code class="language-plaintext highlighter-rouge">process.env.AUTH_URL</code> as url for the requests.</p>

<p>then, we can create a test server that start when we run the tests:</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// auth-server.ts</span>
<span class="k">import</span> <span class="nx">Koa</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">koa</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Router</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">koa-router2</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">actorPool</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./auth-helper</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Koa</span><span class="p">();</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Router</span><span class="p">();</span>

<span class="nx">router</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/authorize</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="nx">ctx</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">auth</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">authorization</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">auth</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="mi">401</span><span class="p">;</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">not authorized</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">actor</span> <span class="o">=</span> <span class="nx">actorPool</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">auth</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">actor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="mi">401</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">body</span> <span class="o">=</span> <span class="nx">actor</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">server</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">router</span><span class="p">.</span><span class="nx">routes</span><span class="p">());</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3003</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// auth-server.ts</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">actorPool</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="nx">Actor</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div>

<p>So the endpoint is now available for your tests and as you can see there’s one logic in the <code class="language-plaintext highlighter-rouge">/authorize</code> endpoints. It uses <code class="language-plaintext highlighter-rouge">actorPool</code> hash map to determine how it should respond with a certain payload. In my tests, it will create a <code class="language-plaintext highlighter-rouge">User</code>, and this User will need to be registered in <code class="language-plaintext highlighter-rouge">actorPool</code>. Then when the request is made, the server will check the same hashmap and determine whether to respond with <code class="language-plaintext highlighter-rouge">401</code> or not.</p>

<h2 id="inject-your-module-using-inversify">Inject your module using Inversify</h2>
<p>This is probably my favourite among all, using <a href="https://github.com/inversify/InversifyJS">Inversify.js</a>! But it requires a bit of commitment, you might end up restructuring your application from scratch. Inversify is an inversion of control (IoC) container for TypeScript and JavaScript. They have a great set of documentation so I highly recommend you to read them through if you are not familiar with IoC. Also if you’d like to check how we use Inversify at <a href="https://ub.io">Ubio</a>, check out our <a href="https://github.com/ubio/node-framework"><code class="language-plaintext highlighter-rouge">node-framework</code></a> repository, It is pretty cool :)</p>

<p>tldr, you can replace your Service with MockService that is designed for your tests. for example, If you made that middleware above as a Service, you can just replace that service to act in a certain way while respecting the same interface and contract. Imagine you have an AuthorizationService:</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nx">AuthService</span> <span class="p">{</span>
    <span class="kd">abstract</span> <span class="nx">authorize</span><span class="p">(</span><span class="nx">ctx</span><span class="p">:</span> <span class="nx">Koa</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">next</span><span class="p">:</span> <span class="nx">Koa</span><span class="p">.</span><span class="nx">Next</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Actor</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">KyungeunAuthService</span> <span class="kd">extends</span> <span class="nx">AuthService</span> <span class="p">{</span>
    <span class="k">async</span> <span class="nx">authorize</span><span class="p">(</span><span class="nx">ctx</span><span class="p">:</span> <span class="nx">Koa</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">next</span><span class="p">:</span> <span class="nx">Koa</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">authorization</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">authorization</span>
        <span class="p">};</span>
        <span class="kd">const</span> <span class="nx">actor</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">AUTH_URL</span><span class="p">,</span> <span class="p">{</span>
            <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">get</span><span class="dl">'</span><span class="p">,</span>
            <span class="nx">headers</span><span class="p">,</span>
        <span class="p">});</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">actor</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">AuthorizationError</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">url</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">await</span> <span class="nx">next</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We defined the abstract class so we define the contract and interface for <code class="language-plaintext highlighter-rouge">authorize()</code> method. In the application, the <code class="language-plaintext highlighter-rouge">KyungeunAuthService</code> will be bound to the container and it will fire the request to the auth server.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">Application</span> <span class="p">{</span>
    <span class="nl">container</span><span class="p">:</span> <span class="nx">Container</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Container</span><span class="p">({</span> <span class="na">skipBaseClassChecks</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">container</span> <span class="o">=</span> <span class="nx">container</span><span class="p">;</span>
        <span class="p">...</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">container</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">AuthService</span><span class="p">).</span><span class="nx">to</span><span class="p">(</span><span class="nx">KyungeunAuthService</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and when we run the test, we can rebind this AuthService, even to a constant value.</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// authorize.test.ts</span>
    <span class="nx">beforeEach</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Application</span><span class="p">();</span>
        <span class="nx">app</span><span class="p">.</span><span class="nx">container</span><span class="p">.</span><span class="nx">rebind</span><span class="p">(</span><span class="nx">AuthService</span><span class="p">).</span><span class="nx">toConstantValue</span><span class="p">({</span>
            <span class="k">async</span> <span class="nx">authorize</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nx">Actor</span><span class="p">({</span>
                    <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">user-number-one</span><span class="dl">'</span><span class="p">,</span>
                    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">KK</span><span class="dl">'</span><span class="p">,</span>
                <span class="p">});</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">});</span>

    <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">authorises user</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">});</span>
</code></pre></div></div>

<p>You noticed that is not technically mocking the requests, but just stubbing the behaviour of the service and method. To be fair, why do we need to make the actual requests if we can simply mimic the behaviour while safely respecting the contract? The main goal (to me)is to manipulate the component in a way that you wish so your tests can be run in a controlled context that fit into your scenario. You can argue that it won’t be a suitable option if your goal is simply checking whether your tests fire the request to the designated url or not.</p>

</div>

        </div>
      </div>
      <footer class="footer">
        <p class="footer__copyright">© 2022 Kyungeun Kim. All rights reserved.</p>
        <div class="footer__social">
            <a rel="github"
                href="https://github.com/kyungeunni"
                title="Kyungeun Kim Github">
                <i class="fab fa-github"></i>
            </a>
            <a rel="twitter"
                href="https://twitter.com/kyungeunni"
                title="Kyungeun Kim Twitter">
                <i class="fab fa-twitter"></i>
            </a>
            <a rel="linkedin"
                href="https://www.linkedin.com/in/kyungeun-kim-541021136"
                title="Kyungeun Kim Linkedin">
                <i class="fab fa-linkedin"></i>
            </a>
          </div>
      </footer>
    </div>
  </body>
</html>
